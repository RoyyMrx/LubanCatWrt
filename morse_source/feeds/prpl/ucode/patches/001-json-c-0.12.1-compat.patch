--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -50,6 +50,17 @@ ELSE()
     ADD_DEFINITIONS(-DHAVE_ARRAY_SHRINK)
   ENDIF()
 ENDIF()
+CHECK_SYMBOL_EXISTS(json_object_get_userdata "json.h" HAVE_RECENT_JSONC)
+IF(HAVE_RECENT_JSONC)
+  ADD_DEFINITIONS(-DHAVE_RECENT_JSONC)
+ELSE()
+  CHECK_SYMBOL_EXISTS(json_object_get_userdata "json-c/json.h" HAVE_RECENT_JSONC2)
+  IF(HAVE_RECENT_JSONC2)
+    ADD_DEFINITIONS(-DHAVE_RECENT_JSONC)
+  ELSE()
+    ADD_DEFINITIONS(-Wno-deprecated-declarations)
+  ENDIF()
+ENDIF()
 UNSET(CMAKE_REQUIRED_LIBRARIES)
 
 SET(LIBRARIES "")
--- a/lib.h
+++ b/lib.h
@@ -186,7 +186,12 @@ uc_add_proto_val(uc_prototype *proto, co
 	if (!proto)
 		return false;
 
+#ifdef HAVE_RECENT_JSONC
 	return json_object_object_add(proto->header.jso, key, value);
+#else
+	json_object_object_add(proto->header.jso, key, value);
+	return true;
+#endif
 }
 
 static inline void
--- a/util.h
+++ b/util.h
@@ -26,6 +26,97 @@
 #include <json-c/json.h>
 
 
+/* legacy json-c compat */
+
+#ifndef HAVE_RECENT_JSONC
+
+# include <json-c/arraylist.h>
+# include <json-c/printbuf.h>
+# include <json-c/json_object_private.h>
+
+# define JSON_C_TO_STRING_NOSLASHESCAPE 0
+
+static inline void *json_object_get_userdata(json_object *jso) {
+	struct json_object *js = jso;
+
+	return js ? js->_userdata : NULL;
+}
+
+static inline void json_object_set_userdata(json_object *jso, void *userdata, json_object_delete_fn *user_delete) {
+	struct json_object *js = jso;
+
+	js->_userdata = userdata;
+	js->_user_delete = user_delete;
+}
+
+static inline json_object *json_object_new_uint64(uint64_t val) {
+	return json_object_new_int64((int64_t)val);
+}
+
+static inline uint64_t json_object_get_uint64(json_object *jso) {
+	return (uint64_t)json_object_get_int64(jso);
+}
+
+static inline int json_object_int_inc(json_object *jso, int64_t val)
+{
+	struct json_object *js = jso;
+
+	if (!js || js->o_type != json_type_int)
+		return 0;
+
+	if (val < 0 && js->o.c_int64 < INT64_MIN - val)
+	{
+		js->o.c_int64 = INT64_MIN;
+	}
+	else
+	{
+		js->o.c_int64 += val;
+	}
+
+	return 1;
+}
+
+static inline size_t json_tokener_get_parse_end(struct json_tokener *tok)
+{
+	return (size_t)tok->char_offset;
+}
+
+static inline json_object *json_object_new_array_ext(size_t val) {
+        return json_object_new_array();
+}
+
+static inline int json_object_array_del_idx(json_object *jso, size_t idx, size_t count)
+{
+	struct json_object *js = jso;
+	struct array_list *arr = js->o.c_array;
+	size_t i, stop;
+
+	/* Avoid overflow in calculation with large indices. */
+	if (idx > ((size_t)-1) - count)
+		return -1;
+
+	stop = idx + count;
+
+	if (idx >= arr->length || stop > arr->length)
+		return -1;
+
+	for (i = idx; i < stop; ++i)
+	{
+		// Because put_idx can skip entries, we need to check if
+		// there's actually anything in each slot we're erasing.
+		if (arr->array[i])
+			arr->free_fn(arr->array[i]);
+	}
+
+	memmove(arr->array + idx, arr->array + stop, (arr->length - stop) * sizeof(void *));
+	arr->length -= count;
+
+	return 0;
+}
+
+#endif
+
+
 /* alignment & array size */
 
 #ifndef ALIGN
--- a/lexer.c
+++ b/lexer.c
@@ -688,7 +688,12 @@ parse_regexp(uc_lexer *lex, bool no_rege
 					json_object_get_string_len(rv->val),
 					json_object_get_string(rv->val));
 
+#ifdef HAVE_RECENT_JSONC
 				json_object_set_string_len(rv->val, s, len);
+#else
+				uc_value_put(rv->val);
+				rv->val = xjs_new_string_len(s, len);
+#endif
 				free(s);
 
 				rv->type = TK_REGEXP;
--- a/vm.c
+++ b/vm.c
@@ -763,7 +763,18 @@ uc_vm_capture_stacktrace(uc_vm *vm, size
 			json_object_object_add(entry, "function", xjs_new_string(name));
 		}
 
+#ifdef HAVE_RECENT_JSONC
 		if (!json_object_equal(last, entry)) {
+#else
+		const char *fn1 = json_object_get_string(json_object_object_get(last, "filename"));
+		const char *fn2 = json_object_get_string(json_object_object_get(entry, "filename"));
+
+		if (!fn1 || !fn2 || strcmp(fn1, fn2) ||
+		    (json_object_get_int64(json_object_object_get(last, "line")) !=
+		     json_object_get_int64(json_object_object_get(entry, "line"))) ||
+		    (json_object_get_int64(json_object_object_get(last, "byte")) !=
+		     json_object_get_int64(json_object_object_get(entry, "byte")))) {
+#endif
 			json_object_array_add(stacktrace, entry);
 			last = entry;
 		}
--- a/value.c
+++ b/value.c
@@ -268,8 +268,12 @@ uc_setval(json_object *scope, json_objec
 		return json_object_get(val);
 	}
 
+#ifdef HAVE_RECENT_JSONC
 	if (json_object_object_add(scope, key ? json_object_get_string(key) : "null", val))
 		return NULL;
+#else
+	json_object_object_add(scope, key ? json_object_get_string(key) : "null", val);
+#endif
 
 	return json_object_get(val);
 }
